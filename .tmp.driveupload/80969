{"ast":null,"code":"var _jsxFileName = \"D:\\\\nmit original\\\\gesture-react\\\\src\\\\WebcamFeed.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction WebcamFeed({\n  websocket,\n  selectedCase\n}) {\n  _s();\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  let frameInterval = null;\n  useEffect(() => {\n    // Function to start the webcam stream\n    const startWebcam = async () => {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          video: true\n        });\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n        }\n      } catch (err) {\n        console.error(\"Error accessing webcam:\", err);\n        alert(\"Could not access the webcam. Please ensure you have a camera connected and grant permission.\");\n      }\n    };\n    startWebcam();\n\n    // Cleanup function to stop the webcam and interval\n    return () => {\n      if (videoRef.current && videoRef.current.srcObject) {\n        const tracks = videoRef.current.srcObject.getTracks();\n        tracks.forEach(track => track.stop());\n      }\n      if (frameInterval) {\n        clearInterval(frameInterval);\n      }\n    };\n  }, []); // Empty dependency array means this effect runs only once on mount\n\n  useEffect(() => {\n    // Effect to send frames when WebSocket is connected and a case is selected\n    if (websocket && websocket.readyState === WebSocket.OPEN && selectedCase !== null) {\n      console.log(`Starting frame sending for case ${selectedCase}`);\n\n      // Clear any existing interval before starting a new one\n      if (frameInterval) {\n        clearInterval(frameInterval);\n      }\n      frameInterval = setInterval(() => {\n        if (videoRef.current && canvasRef.current) {\n          const context = canvasRef.current.getContext('2d');\n          // Set canvas dimensions to match video feed\n          canvasRef.current.width = videoRef.current.videoWidth;\n          canvasRef.current.height = videoRef.current.videoHeight;\n\n          // Draw the current video frame onto the canvas\n          context.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n\n          // Get image data from the canvas (e.g., as a Blob or Base64)\n          // Sending as Blob is generally more efficient than Base64\n          canvasRef.current.toBlob(blob => {\n            if (blob && websocket && websocket.readyState === WebSocket.OPEN) {\n              // You might need to send the case number with each frame\n              // The backend expects JSON with 'case' and 'frame'\n              const reader = new FileReader();\n              reader.onload = () => {\n                // Send frame data as ArrayBuffer\n                websocket.send(JSON.stringify({\n                  case: selectedCase,\n                  frame: Array.from(new Uint8Array(reader.result)) // Convert ArrayBuffer to list of integers\n                }));\n              };\n              reader.readAsArrayBuffer(blob);\n            }\n          }, 'image/jpeg'); // Specify image format\n        }\n      }, 100); // Send frame every 100ms (adjust as needed)\n    } else {\n      // Stop sending frames if WebSocket is not open or no case is selected\n      console.log(\"Stopping frame sending.\");\n      if (frameInterval) {\n        clearInterval(frameInterval);\n        frameInterval = null; // Reset interval ID\n      }\n    }\n\n    // Cleanup function to clear the interval when selectedCase or websocket changes\n    return () => {\n      if (frameInterval) {\n        clearInterval(frameInterval);\n        frameInterval = null; // Reset interval ID\n      }\n    };\n  }, [websocket, selectedCase]); // Effect runs when websocket or selectedCase changes\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      autoPlay: true,\n      playsInline: true,\n      style: {\n        display: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 100,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        width: '100%',\n        height: 'auto'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 102,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 98,\n    columnNumber: 5\n  }, this);\n}\n_s(WebcamFeed, \"ak7+uYfCLCD14UmZDNefIcFbPqc=\");\n_c = WebcamFeed;\nexport default WebcamFeed;\nvar _c;\n$RefreshReg$(_c, \"WebcamFeed\");","map":{"version":3,"names":["React","useRef","useEffect","jsxDEV","_jsxDEV","WebcamFeed","websocket","selectedCase","_s","videoRef","canvasRef","frameInterval","startWebcam","stream","navigator","mediaDevices","getUserMedia","video","current","srcObject","err","console","error","alert","tracks","getTracks","forEach","track","stop","clearInterval","readyState","WebSocket","OPEN","log","setInterval","context","getContext","width","videoWidth","height","videoHeight","drawImage","toBlob","blob","reader","FileReader","onload","send","JSON","stringify","case","frame","Array","from","Uint8Array","result","readAsArrayBuffer","children","ref","autoPlay","playsInline","style","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/nmit original/gesture-react/src/WebcamFeed.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\n\nfunction WebcamFeed({ websocket, selectedCase }) {\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  let frameInterval = null;\n\n  useEffect(() => {\n    // Function to start the webcam stream\n    const startWebcam = async () => {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n        }\n      } catch (err) {\n        console.error(\"Error accessing webcam:\", err);\n        alert(\"Could not access the webcam. Please ensure you have a camera connected and grant permission.\");\n      }\n    };\n\n    startWebcam();\n\n    // Cleanup function to stop the webcam and interval\n    return () => {\n      if (videoRef.current && videoRef.current.srcObject) {\n        const tracks = videoRef.current.srcObject.getTracks();\n        tracks.forEach(track => track.stop());\n      }\n      if (frameInterval) {\n        clearInterval(frameInterval);\n      }\n    };\n  }, []); // Empty dependency array means this effect runs only once on mount\n\n  useEffect(() => {\n    // Effect to send frames when WebSocket is connected and a case is selected\n    if (websocket && websocket.readyState === WebSocket.OPEN && selectedCase !== null) {\n      console.log(`Starting frame sending for case ${selectedCase}`);\n\n      // Clear any existing interval before starting a new one\n      if (frameInterval) {\n        clearInterval(frameInterval);\n      }\n\n      frameInterval = setInterval(() => {\n        if (videoRef.current && canvasRef.current) {\n          const context = canvasRef.current.getContext('2d');\n          // Set canvas dimensions to match video feed\n          canvasRef.current.width = videoRef.current.videoWidth;\n          canvasRef.current.height = videoRef.current.videoHeight;\n\n          // Draw the current video frame onto the canvas\n          context.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n\n          // Get image data from the canvas (e.g., as a Blob or Base64)\n          // Sending as Blob is generally more efficient than Base64\n          canvasRef.current.toBlob((blob) => {\n            if (blob && websocket && websocket.readyState === WebSocket.OPEN) {\n              // You might need to send the case number with each frame\n              // The backend expects JSON with 'case' and 'frame'\n              const reader = new FileReader();\n              reader.onload = () => {\n                 // Send frame data as ArrayBuffer\n                 websocket.send(JSON.stringify({\n                   case: selectedCase,\n                   frame: Array.from(new Uint8Array(reader.result)) // Convert ArrayBuffer to list of integers\n                 }));\n              };\n              reader.readAsArrayBuffer(blob);\n\n            }\n          }, 'image/jpeg'); // Specify image format\n\n        }\n      }, 100); // Send frame every 100ms (adjust as needed)\n\n    } else {\n      // Stop sending frames if WebSocket is not open or no case is selected\n      console.log(\"Stopping frame sending.\");\n      if (frameInterval) {\n        clearInterval(frameInterval);\n        frameInterval = null; // Reset interval ID\n      }\n    }\n\n    // Cleanup function to clear the interval when selectedCase or websocket changes\n    return () => {\n      if (frameInterval) {\n        clearInterval(frameInterval);\n        frameInterval = null; // Reset interval ID\n      }\n    };\n\n  }, [websocket, selectedCase]); // Effect runs when websocket or selectedCase changes\n\n  return (\n    <div>\n      {/* The video element displays the raw webcam feed (optional, can be hidden) */}\n      <video ref={videoRef} autoPlay playsInline style={{ display: 'none' }}></video>\n      {/* The canvas element is used to capture frames for sending */}\n      <canvas ref={canvasRef} style={{ width: '100%', height: 'auto' }}></canvas>\n    </div>\n  );\n}\n\nexport default WebcamFeed;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}