{"ast":null,"code":"var _jsxFileName = \"D:\\\\nmit original\\\\gesture-react\\\\src\\\\WebcamFeed.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction WebcamFeed({\n  websocket,\n  selectedCase\n}) {\n  _s();\n  // We need both videoRef (to get the raw stream) and canvasRef (to draw/send/display)\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const frameIntervalRef = useRef(null);\n  // Use a ref to store the video stream itself for cleanup\n  const videoStreamRef = useRef(null);\n  useEffect(() => {\n    console.log('WebcamFeed: Initial mount effect running.');\n    // Function to start the webcam stream\n    const startWebcam = async () => {\n      try {\n        console.log('WebcamFeed: Requesting webcam access...');\n        const stream = await navigator.mediaDevices.getUserMedia({\n          video: true\n        });\n        videoStreamRef.current = stream; // Store stream in ref for cleanup\n        console.log('WebcamFeed: Webcam stream obtained.');\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n        }\n      } catch (err) {\n        console.error(\"WebcamFeed: Error accessing webcam:\", err);\n        alert(\"Could not access the webcam. Please ensure you have a camera connected and grant permission.\");\n      }\n    };\n    startWebcam();\n\n    // Cleanup function to stop the webcam stream and interval\n    return () => {\n      console.log('WebcamFeed: Cleaning up webcam stream and interval.');\n      // Capture the current stream value for cleanup\n      const currentStream = videoStreamRef.current;\n      if (currentStream) {\n        const tracks = currentStream.getTracks();\n        tracks.forEach(track => track.stop());\n      }\n      // Clear the interval using the ref\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n      }\n    };\n  }, []); // Empty dependency array means this effect runs only once on mount\n\n  useEffect(() => {\n    console.log('WebcamFeed: WebSocket or selectedCase changed. Checking conditions...');\n    console.log('WebcamFeed: websocket:', websocket, 'selectedCase:', selectedCase);\n\n    // Effect to send frames when WebSocket is connected and a case is selected\n    if (websocket && websocket.readyState === WebSocket.OPEN && selectedCase !== null) {\n      console.log(`WebcamFeed: Conditions met. Starting frame sending for case ${selectedCase}`);\n\n      // Clear any existing interval before starting a new one\n      if (frameIntervalRef.current) {\n        console.log('WebcamFeed: Clearing existing frame interval.');\n        clearInterval(frameIntervalRef.current);\n      }\n\n      // Store the new interval ID in the ref\n      frameIntervalRef.current = setInterval(() => {\n        if (videoRef.current && canvasRef.current) {\n          const context = canvasRef.current.getContext('2d');\n          // Set canvas dimensions to match video feed\n          canvasRef.current.width = videoRef.current.videoWidth;\n          canvasRef.current.height = videoRef.current.videoHeight;\n\n          // Draw the current video frame onto the canvas for sending\n          // Draw the frame mirrored horizontally\n          context.save();\n          context.scale(-1, 1);\n          context.drawImage(videoRef.current, -canvasRef.current.width, 0, canvasRef.current.width, canvasRef.current.height);\n          context.restore();\n\n          // Get image data from the canvas as a Base64 data URL\n          const dataUrl = canvasRef.current.toDataURL('image/jpeg', 0.7); // Specify image format and quality\n\n          if (websocket && websocket.readyState === WebSocket.OPEN) {\n            // Send frame data as Base64 string\n            // console.log('WebcamFeed: Sending frame data...'); // Uncomment for noisy logging\n            // Inside your frame processing and sending logic (e.g., in a setInterval or requestAnimationFrame loop)\n            if (websocket && websocket.readyState === WebSocket.OPEN) {\n              // Assume base64ImageData is the base64 string of the current frame\n              // Assume selectedCase is the currently selected case number (e.g., 1, 2, or 3)\n\n              const dataToSend = {\n                case: selectedCase,\n                frame: base64ImageData\n              };\n              websocket.send(JSON.stringify(dataToSend));\n            }\n          } else {\n            console.log('WebcamFeed: Cannot send frame. WebSocket not ready.');\n          }\n        } else {\n          console.log('WebcamFeed: Cannot capture frame. videoRef or canvasRef not ready.');\n        }\n      }, 200); // Send frame every 200ms (adjust as needed) // Changed from 100 to 200\n\n      // Add WebSocket message listener here\n      websocket.onmessage = event => {\n        try {\n          console.log(\"WebcamFeed: Raw message received:\", event.data); // Log the raw message\n          const data = JSON.parse(event.data);\n          console.log(\"WebcamFeed: Parsed message data:\", data); // Log the parsed data\n          console.log(\"WebcamFeed: Received frame data:\", data.frame ? \"Exists\" : \"Does not exist\"); // Check if frame exists\n          console.log(\"WebcamFeed: Canvas ref current:\", canvasRef.current); // Check if canvas ref is available\n\n          if (data.frame && canvasRef.current) {\n            console.log(\"WebcamFeed: Received frame data and canvas is ready. Attempting to draw.\");\n            // Received an annotated frame from the backend\n            const img = new Image();\n            img.onload = () => {\n              console.log(\"WebcamFeed: Image loaded. Drawing to canvas.\"); // Log when image is loaded\n              const context = canvasRef.current.getContext('2d');\n              // Clear the canvas before drawing the new frame\n              context.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n              // Draw the received image onto the canvas for display\n              // Ensure canvas size matches the received image size if necessary,\n              // or draw the image scaled to the current canvas size.\n              // For simplicity, let's assume backend sends frames at the canvas size.\n              context.drawImage(img, 0, 0, canvasRef.current.width, canvasRef.current.height);\n              console.log(\"WebcamFeed: Image drawn to canvas.\"); // Log after drawing\n            };\n            img.onerror = e => {\n              console.error(\"WebcamFeed: Error loading image:\", e); // Log image loading errors\n            };\n            img.src = 'data:image/jpeg;base64,' + data.frame;\n          }\n          // You can also handle other messages here, e.g., gesture names\n          // This part might be better handled in the parent App component\n          // and passed down as a prop if needed, but for now, we'll just log.\n          if (data.gesture) {\n            console.log(\"WebcamFeed: Received gesture:\", data.gesture);\n            // If you want to display gesture result here, you'd need a state/prop\n          }\n        } catch (e) {\n          console.error(\"WebcamFeed: Error parsing message from backend:\", e);\n        }\n      };\n    } else {\n      // Stop sending frames if WebSocket is not open or no case is selected\n      console.log(\"WebcamFeed: Conditions not met. Stopping frame sending.\");\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n        frameIntervalRef.current = null; // Reset interval ID\n      }\n      // Remove the message listener when conditions are not met\n      if (websocket) {\n        websocket.onmessage = null; // Or set to a default handler\n      }\n    }\n\n    // Cleanup function to clear the interval and message listener\n    return () => {\n      console.log('WebcamFeed: Cleanup effect running. Clearing frame interval and message listener.');\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n        frameIntervalRef.current = null; // Reset interval ID\n      }\n      if (websocket) {\n        websocket.onmessage = null; // Remove the message listener\n      }\n    };\n  }, [websocket, selectedCase]); // Effect runs when websocket or selectedCase changes\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      autoPlay: true,\n      playsInline: true,\n      style: {\n        display: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 179,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        width: '100%',\n        height: 'auto'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 182,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 177,\n    columnNumber: 5\n  }, this);\n}\n_s(WebcamFeed, \"lokwfi5Otlr/Br5LH+Gei3fGix8=\");\n_c = WebcamFeed;\nexport default WebcamFeed;\nvar _c;\n$RefreshReg$(_c, \"WebcamFeed\");","map":{"version":3,"names":["React","useRef","useEffect","jsxDEV","_jsxDEV","WebcamFeed","websocket","selectedCase","_s","videoRef","canvasRef","frameIntervalRef","videoStreamRef","console","log","startWebcam","stream","navigator","mediaDevices","getUserMedia","video","current","srcObject","err","error","alert","currentStream","tracks","getTracks","forEach","track","stop","clearInterval","readyState","WebSocket","OPEN","setInterval","context","getContext","width","videoWidth","height","videoHeight","save","scale","drawImage","restore","dataUrl","toDataURL","dataToSend","case","frame","base64ImageData","send","JSON","stringify","onmessage","event","data","parse","img","Image","onload","clearRect","onerror","e","src","gesture","children","ref","autoPlay","playsInline","style","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/nmit original/gesture-react/src/WebcamFeed.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\n\nfunction WebcamFeed({ websocket, selectedCase }) {\n  // We need both videoRef (to get the raw stream) and canvasRef (to draw/send/display)\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  const frameIntervalRef = useRef(null);\n  // Use a ref to store the video stream itself for cleanup\n  const videoStreamRef = useRef(null);\n\n\n  useEffect(() => {\n    console.log('WebcamFeed: Initial mount effect running.');\n    // Function to start the webcam stream\n    const startWebcam = async () => {\n      try {\n        console.log('WebcamFeed: Requesting webcam access...');\n        const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n        videoStreamRef.current = stream; // Store stream in ref for cleanup\n        console.log('WebcamFeed: Webcam stream obtained.');\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n        }\n      } catch (err) {\n        console.error(\"WebcamFeed: Error accessing webcam:\", err);\n        alert(\"Could not access the webcam. Please ensure you have a camera connected and grant permission.\");\n      }\n    };\n\n    startWebcam();\n\n    // Cleanup function to stop the webcam stream and interval\n    return () => {\n      console.log('WebcamFeed: Cleaning up webcam stream and interval.');\n      // Capture the current stream value for cleanup\n      const currentStream = videoStreamRef.current;\n      if (currentStream) {\n        const tracks = currentStream.getTracks();\n        tracks.forEach(track => track.stop());\n      }\n      // Clear the interval using the ref\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n      }\n    };\n  }, []); // Empty dependency array means this effect runs only once on mount\n\n  useEffect(() => {\n    console.log('WebcamFeed: WebSocket or selectedCase changed. Checking conditions...');\n    console.log('WebcamFeed: websocket:', websocket, 'selectedCase:', selectedCase);\n\n    // Effect to send frames when WebSocket is connected and a case is selected\n    if (websocket && websocket.readyState === WebSocket.OPEN && selectedCase !== null) {\n      console.log(`WebcamFeed: Conditions met. Starting frame sending for case ${selectedCase}`);\n\n      // Clear any existing interval before starting a new one\n      if (frameIntervalRef.current) {\n        console.log('WebcamFeed: Clearing existing frame interval.');\n        clearInterval(frameIntervalRef.current);\n      }\n\n      // Store the new interval ID in the ref\n      frameIntervalRef.current = setInterval(() => {\n        if (videoRef.current && canvasRef.current) {\n          const context = canvasRef.current.getContext('2d');\n          // Set canvas dimensions to match video feed\n          canvasRef.current.width = videoRef.current.videoWidth;\n          canvasRef.current.height = videoRef.current.videoHeight;\n\n          // Draw the current video frame onto the canvas for sending\n          // Draw the frame mirrored horizontally\n          context.save();\n          context.scale(-1, 1);\n          context.drawImage(videoRef.current, -canvasRef.current.width, 0, canvasRef.current.width, canvasRef.current.height);\n          context.restore();\n\n\n          // Get image data from the canvas as a Base64 data URL\n          const dataUrl = canvasRef.current.toDataURL('image/jpeg', 0.7); // Specify image format and quality\n\n          if (websocket && websocket.readyState === WebSocket.OPEN) {\n             // Send frame data as Base64 string\n             // console.log('WebcamFeed: Sending frame data...'); // Uncomment for noisy logging\n             // Inside your frame processing and sending logic (e.g., in a setInterval or requestAnimationFrame loop)\n             if (websocket && websocket.readyState === WebSocket.OPEN) {\n             // Assume base64ImageData is the base64 string of the current frame\n             // Assume selectedCase is the currently selected case number (e.g., 1, 2, or 3)\n             \n             const dataToSend = {\n             case: selectedCase,\n             frame: base64ImageData\n             };\n             \n             websocket.send(JSON.stringify(dataToSend));\n             }\n          } else {\n              console.log('WebcamFeed: Cannot send frame. WebSocket not ready.');\n          }\n\n        } else {\n            console.log('WebcamFeed: Cannot capture frame. videoRef or canvasRef not ready.');\n        }\n      }, 200); // Send frame every 200ms (adjust as needed) // Changed from 100 to 200\n\n      // Add WebSocket message listener here\n      websocket.onmessage = (event) => {\n        try {\n          console.log(\"WebcamFeed: Raw message received:\", event.data); // Log the raw message\n          const data = JSON.parse(event.data);\n          console.log(\"WebcamFeed: Parsed message data:\", data); // Log the parsed data\n          console.log(\"WebcamFeed: Received frame data:\", data.frame ? \"Exists\" : \"Does not exist\"); // Check if frame exists\n          console.log(\"WebcamFeed: Canvas ref current:\", canvasRef.current); // Check if canvas ref is available\n\n          if (data.frame && canvasRef.current) {\n            console.log(\"WebcamFeed: Received frame data and canvas is ready. Attempting to draw.\");\n            // Received an annotated frame from the backend\n            const img = new Image();\n            img.onload = () => {\n              console.log(\"WebcamFeed: Image loaded. Drawing to canvas.\"); // Log when image is loaded\n              const context = canvasRef.current.getContext('2d');\n              // Clear the canvas before drawing the new frame\n              context.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n              // Draw the received image onto the canvas for display\n              // Ensure canvas size matches the received image size if necessary,\n              // or draw the image scaled to the current canvas size.\n              // For simplicity, let's assume backend sends frames at the canvas size.\n              context.drawImage(img, 0, 0, canvasRef.current.width, canvasRef.current.height);\n              console.log(\"WebcamFeed: Image drawn to canvas.\"); // Log after drawing\n            };\n            img.onerror = (e) => {\n                console.error(\"WebcamFeed: Error loading image:\", e); // Log image loading errors\n            };\n            img.src = 'data:image/jpeg;base64,' + data.frame;\n          }\n          // You can also handle other messages here, e.g., gesture names\n          // This part might be better handled in the parent App component\n          // and passed down as a prop if needed, but for now, we'll just log.\n          if (data.gesture) {\n              console.log(\"WebcamFeed: Received gesture:\", data.gesture);\n              // If you want to display gesture result here, you'd need a state/prop\n          }\n\n        } catch (e) {\n          console.error(\"WebcamFeed: Error parsing message from backend:\", e);\n        }\n      };\n\n\n    } else {\n      // Stop sending frames if WebSocket is not open or no case is selected\n      console.log(\"WebcamFeed: Conditions not met. Stopping frame sending.\");\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n        frameIntervalRef.current = null; // Reset interval ID\n      }\n       // Remove the message listener when conditions are not met\n       if (websocket) {\n           websocket.onmessage = null; // Or set to a default handler\n       }\n    }\n\n    // Cleanup function to clear the interval and message listener\n    return () => {\n      console.log('WebcamFeed: Cleanup effect running. Clearing frame interval and message listener.');\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n        frameIntervalRef.current = null; // Reset interval ID\n      }\n      if (websocket) {\n          websocket.onmessage = null; // Remove the message listener\n      }\n    };\n\n  }, [websocket, selectedCase]); // Effect runs when websocket or selectedCase changes\n\n  return (\n    <div>\n      {/* The video element is hidden, used only to get the raw stream */}\n      <video ref={videoRef} autoPlay playsInline style={{ display: 'none' }}></video>\n      {/* The canvas element is used to capture frames for sending AND display the processed feed */}\n      {/* Remove the display: 'none' style */}\n      <canvas ref={canvasRef} style={{ width: '100%', height: 'auto' }}></canvas>\n    </div>\n  );\n}\n\nexport default WebcamFeed;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}