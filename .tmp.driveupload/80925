{"ast":null,"code":"var _jsxFileName = \"D:\\\\nmit original\\\\gesture-react\\\\src\\\\WebcamFeed.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction WebcamFeed({\n  websocket,\n  selectedCase\n}) {\n  _s();\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  // Use useRef for frameInterval to persist its value across renders\n  const frameIntervalRef = useRef(null);\n  useEffect(() => {\n    console.log('WebcamFeed: Initial mount effect running.');\n    // Function to start the webcam stream\n    const startWebcam = async () => {\n      try {\n        console.log('WebcamFeed: Requesting webcam access...');\n        const stream = await navigator.mediaDevices.getUserMedia({\n          video: true\n        });\n        console.log('WebcamFeed: Webcam stream obtained.');\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n        }\n      } catch (err) {\n        console.error(\"WebcamFeed: Error accessing webcam:\", err);\n        alert(\"Could not access the webcam. Please ensure you have a camera connected and grant permission.\");\n      }\n    };\n    startWebcam();\n\n    // Cleanup function to stop the webcam and interval\n    return () => {\n      console.log('WebcamFeed: Cleaning up webcam stream and interval.');\n      if (videoRef.current && videoRef.current.srcObject) {\n        const tracks = videoRef.current.srcObject.getTracks();\n        tracks.forEach(track => track.stop());\n      }\n      // Clear the interval using the ref\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n      }\n    };\n  }, []); // Empty dependency array means this effect runs only once on mount\n\n  useEffect(() => {\n    console.log('WebcamFeed: WebSocket or selectedCase changed. Checking conditions...');\n    console.log('WebcamFeed: websocket:', websocket, 'selectedCase:', selectedCase);\n\n    // Effect to send frames when WebSocket is connected and a case is selected\n    if (websocket && websocket.readyState === WebSocket.OPEN && selectedCase !== null) {\n      console.log(`WebcamFeed: Conditions met. Starting frame sending for case ${selectedCase}`);\n\n      // Clear any existing interval before starting a new one\n      if (frameIntervalRef.current) {\n        console.log('WebcamFeed: Clearing existing frame interval.');\n        clearInterval(frameIntervalRef.current);\n      }\n\n      // Store the new interval ID in the ref\n      frameIntervalRef.current = setInterval(() => {\n        if (videoRef.current && canvasRef.current) {\n          const context = canvasRef.current.getContext('2d');\n          // Set canvas dimensions to match video feed\n          canvasRef.current.width = videoRef.current.videoWidth;\n          canvasRef.current.height = videoRef.current.videoHeight;\n\n          // Draw the current video frame onto the canvas\n          context.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n\n          // Get image data from the canvas (e.g., as a Blob or Base64)\n          canvasRef.current.toBlob(blob => {\n            if (blob && websocket && websocket.readyState === WebSocket.OPEN) {\n              const reader = new FileReader();\n              reader.onload = () => {\n                // Send frame data as ArrayBuffer\n                // console.log('WebcamFeed: Sending frame data...'); // Uncomment for noisy logging\n                websocket.send(JSON.stringify({\n                  case: selectedCase,\n                  frame: Array.from(new Uint8Array(reader.result)) // Convert ArrayBuffer to list of integers\n                }));\n              };\n              reader.readAsArrayBuffer(blob);\n            } else {\n              console.log('WebcamFeed: Cannot send frame. Blob or WebSocket not ready.');\n            }\n          }, 'image/jpeg'); // Specify image format\n        } else {\n          console.log('WebcamFeed: Cannot capture frame. videoRef or canvasRef not ready.');\n        }\n      }, 100); // Send frame every 100ms (adjust as needed)\n    } else {\n      // Stop sending frames if WebSocket is not open or no case is selected\n      console.log(\"WebcamFeed: Conditions not met. Stopping frame sending.\");\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n        frameIntervalRef.current = null; // Reset interval ID\n      }\n    }\n\n    // Cleanup function to clear the interval when selectedCase or websocket changes\n    return () => {\n      console.log('WebcamFeed: Cleanup effect running. Clearing frame interval.');\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n        frameIntervalRef.current = null; // Reset interval ID\n      }\n    };\n  }, [websocket, selectedCase]); // Effect runs when websocket or selectedCase changes\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      autoPlay: true,\n      playsInline: true,\n      style: {\n        display: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 114,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        width: '100%',\n        height: 'auto'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 112,\n    columnNumber: 5\n  }, this);\n}\n_s(WebcamFeed, \"QYsoXIPwb00m3zTNn/XFPM0+PL0=\");\n_c = WebcamFeed;\nexport default WebcamFeed;\nvar _c;\n$RefreshReg$(_c, \"WebcamFeed\");","map":{"version":3,"names":["React","useRef","useEffect","jsxDEV","_jsxDEV","WebcamFeed","websocket","selectedCase","_s","videoRef","canvasRef","frameIntervalRef","console","log","startWebcam","stream","navigator","mediaDevices","getUserMedia","video","current","srcObject","err","error","alert","tracks","getTracks","forEach","track","stop","clearInterval","readyState","WebSocket","OPEN","setInterval","context","getContext","width","videoWidth","height","videoHeight","drawImage","toBlob","blob","reader","FileReader","onload","send","JSON","stringify","case","frame","Array","from","Uint8Array","result","readAsArrayBuffer","children","ref","autoPlay","playsInline","style","display","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/nmit original/gesture-react/src/WebcamFeed.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\n\nfunction WebcamFeed({ websocket, selectedCase }) {\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  // Use useRef for frameInterval to persist its value across renders\n  const frameIntervalRef = useRef(null);\n\n  useEffect(() => {\n    console.log('WebcamFeed: Initial mount effect running.');\n    // Function to start the webcam stream\n    const startWebcam = async () => {\n      try {\n        console.log('WebcamFeed: Requesting webcam access...');\n        const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n        console.log('WebcamFeed: Webcam stream obtained.');\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n        }\n      } catch (err) {\n        console.error(\"WebcamFeed: Error accessing webcam:\", err);\n        alert(\"Could not access the webcam. Please ensure you have a camera connected and grant permission.\");\n      }\n    };\n\n    startWebcam();\n\n    // Cleanup function to stop the webcam and interval\n    return () => {\n      console.log('WebcamFeed: Cleaning up webcam stream and interval.');\n      if (videoRef.current && videoRef.current.srcObject) {\n        const tracks = videoRef.current.srcObject.getTracks();\n        tracks.forEach(track => track.stop());\n      }\n      // Clear the interval using the ref\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n      }\n    };\n  }, []); // Empty dependency array means this effect runs only once on mount\n\n  useEffect(() => {\n    console.log('WebcamFeed: WebSocket or selectedCase changed. Checking conditions...');\n    console.log('WebcamFeed: websocket:', websocket, 'selectedCase:', selectedCase);\n\n    // Effect to send frames when WebSocket is connected and a case is selected\n    if (websocket && websocket.readyState === WebSocket.OPEN && selectedCase !== null) {\n      console.log(`WebcamFeed: Conditions met. Starting frame sending for case ${selectedCase}`);\n\n      // Clear any existing interval before starting a new one\n      if (frameIntervalRef.current) {\n        console.log('WebcamFeed: Clearing existing frame interval.');\n        clearInterval(frameIntervalRef.current);\n      }\n\n      // Store the new interval ID in the ref\n      frameIntervalRef.current = setInterval(() => {\n        if (videoRef.current && canvasRef.current) {\n          const context = canvasRef.current.getContext('2d');\n          // Set canvas dimensions to match video feed\n          canvasRef.current.width = videoRef.current.videoWidth;\n          canvasRef.current.height = videoRef.current.videoHeight;\n\n          // Draw the current video frame onto the canvas\n          context.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n\n          // Get image data from the canvas (e.g., as a Blob or Base64)\n          canvasRef.current.toBlob((blob) => {\n            if (blob && websocket && websocket.readyState === WebSocket.OPEN) {\n              const reader = new FileReader();\n              reader.onload = () => {\n                 // Send frame data as ArrayBuffer\n                 // console.log('WebcamFeed: Sending frame data...'); // Uncomment for noisy logging\n                 websocket.send(JSON.stringify({\n                   case: selectedCase,\n                   frame: Array.from(new Uint8Array(reader.result)) // Convert ArrayBuffer to list of integers\n                 }));\n              };\n              reader.readAsArrayBuffer(blob);\n\n            } else {\n                console.log('WebcamFeed: Cannot send frame. Blob or WebSocket not ready.');\n            }\n          }, 'image/jpeg'); // Specify image format\n\n        } else {\n            console.log('WebcamFeed: Cannot capture frame. videoRef or canvasRef not ready.');\n        }\n      }, 100); // Send frame every 100ms (adjust as needed)\n\n    } else {\n      // Stop sending frames if WebSocket is not open or no case is selected\n      console.log(\"WebcamFeed: Conditions not met. Stopping frame sending.\");\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n        frameIntervalRef.current = null; // Reset interval ID\n      }\n    }\n\n    // Cleanup function to clear the interval when selectedCase or websocket changes\n    return () => {\n      console.log('WebcamFeed: Cleanup effect running. Clearing frame interval.');\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n        frameIntervalRef.current = null; // Reset interval ID\n      }\n    };\n\n  }, [websocket, selectedCase]); // Effect runs when websocket or selectedCase changes\n\n  return (\n    <div>\n      {/* The video element displays the raw webcam feed (optional, can be hidden) */}\n      <video ref={videoRef} autoPlay playsInline style={{ display: 'none' }}></video>\n      {/* The canvas element is used to capture frames for sending */}\n      <canvas ref={canvasRef} style={{ width: '100%', height: 'auto' }}></canvas>\n    </div>\n  );\n}\n\nexport default WebcamFeed;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}