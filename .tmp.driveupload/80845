{"ast":null,"code":"var _jsxFileName = \"D:\\\\nmit original\\\\gesture-react\\\\src\\\\WebcamFeed.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction WebcamFeed({\n  websocket,\n  selectedCase\n}) {\n  _s();\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  // Use useRef for frameInterval to persist its value across renders\n  const frameIntervalRef = useRef(null);\n  useEffect(() => {\n    console.log('WebcamFeed: Initial mount effect running.');\n    // Function to start the webcam stream\n    const startWebcam = async () => {\n      try {\n        console.log('WebcamFeed: Requesting webcam access...');\n        const stream = await navigator.mediaDevices.getUserMedia({\n          video: true\n        });\n        console.log('WebcamFeed: Webcam stream obtained.');\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n        }\n      } catch (err) {\n        console.error(\"WebcamFeed: Error accessing webcam:\", err);\n        alert(\"Could not access the webcam. Please ensure you have a camera connected and grant permission.\");\n      }\n    };\n    startWebcam();\n\n    // Cleanup function to stop the webcam and interval\n    return () => {\n      console.log('WebcamFeed: Cleaning up webcam stream and interval.');\n      if (videoRef.current && videoRef.current.srcObject) {\n        const tracks = videoRef.current.srcObject.getTracks();\n        tracks.forEach(track => track.stop());\n      }\n      // Clear the interval using the ref\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n      }\n    };\n  }, []); // Empty dependency array means this effect runs only once on mount\n\n  useEffect(() => {\n    console.log('WebcamFeed: WebSocket or selectedCase changed. Checking conditions...');\n    console.log('WebcamFeed: websocket:', websocket, 'selectedCase:', selectedCase);\n\n    // Effect to send frames when WebSocket is connected and a case is selected\n    if (websocket && websocket.readyState === WebSocket.OPEN && selectedCase !== null) {\n      console.log(`WebcamFeed: Conditions met. Starting frame sending for case ${selectedCase}`);\n\n      // Clear any existing interval before starting a new one\n      if (frameIntervalRef.current) {\n        console.log('WebcamFeed: Clearing existing frame interval.');\n        clearInterval(frameIntervalRef.current);\n      }\n\n      // Store the new interval ID in the ref\n      frameIntervalRef.current = setInterval(() => {\n        if (videoRef.current && canvasRef.current) {\n          const context = canvasRef.current.getContext('2d');\n          // Set canvas dimensions to match video feed\n          canvasRef.current.width = videoRef.current.videoWidth;\n          canvasRef.current.height = videoRef.current.videoHeight;\n\n          // Draw the current video frame onto the canvas\n          context.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n\n          // Get image data from the canvas as a Base64 data URL\n          const dataUrl = canvasRef.current.toDataURL('image/jpeg', 0.7); // Specify image format and quality\n\n          if (websocket && websocket.readyState === WebSocket.OPEN) {\n            // Send frame data as Base64 string\n            // console.log('WebcamFeed: Sending frame data...'); // Uncomment for noisy logging\n            websocket.send(JSON.stringify({\n              case: selectedCase,\n              frame: dataUrl // Send the Base64 data URL string\n            }));\n          } else {\n            console.log('WebcamFeed: Cannot send frame. WebSocket not ready.');\n          }\n        } else {\n          console.log('WebcamFeed: Cannot capture frame. videoRef or canvasRef not ready.');\n        }\n      }, 100); // Send frame every 100ms (adjust as needed)\n    } else {\n      // Stop sending frames if WebSocket is not open or no case is selected\n      console.log(\"WebcamFeed: Conditions not met. Stopping frame sending.\");\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n        frameIntervalRef.current = null; // Reset interval ID\n      }\n    }\n\n    // Cleanup function to clear the interval when selectedCase or websocket changes\n    return () => {\n      console.log('WebcamFeed: Cleanup effect running. Clearing frame interval.');\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n        frameIntervalRef.current = null; // Reset interval ID\n      }\n    };\n  }, [websocket, selectedCase]); // Effect runs when websocket or selectedCase changes\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      autoPlay: true,\n      playsInline: true,\n      style: {\n        width: '100%',\n        height: 'auto'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 109,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      style: {\n        display: 'none'\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 111,\n      columnNumber: 7\n    }, this), \" \"]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 107,\n    columnNumber: 5\n  }, this);\n}\n_s(WebcamFeed, \"QYsoXIPwb00m3zTNn/XFPM0+PL0=\");\n_c = WebcamFeed;\nexport default WebcamFeed;\nvar _c;\n$RefreshReg$(_c, \"WebcamFeed\");","map":{"version":3,"names":["React","useRef","useEffect","jsxDEV","_jsxDEV","WebcamFeed","websocket","selectedCase","_s","videoRef","canvasRef","frameIntervalRef","console","log","startWebcam","stream","navigator","mediaDevices","getUserMedia","video","current","srcObject","err","error","alert","tracks","getTracks","forEach","track","stop","clearInterval","readyState","WebSocket","OPEN","setInterval","context","getContext","width","videoWidth","height","videoHeight","drawImage","dataUrl","toDataURL","send","JSON","stringify","case","frame","children","ref","autoPlay","playsInline","style","fileName","_jsxFileName","lineNumber","columnNumber","display","_c","$RefreshReg$"],"sources":["D:/nmit original/gesture-react/src/WebcamFeed.js"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\n\nfunction WebcamFeed({ websocket, selectedCase }) {\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n  // Use useRef for frameInterval to persist its value across renders\n  const frameIntervalRef = useRef(null);\n\n  useEffect(() => {\n    console.log('WebcamFeed: Initial mount effect running.');\n    // Function to start the webcam stream\n    const startWebcam = async () => {\n      try {\n        console.log('WebcamFeed: Requesting webcam access...');\n        const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n        console.log('WebcamFeed: Webcam stream obtained.');\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n        }\n      } catch (err) {\n        console.error(\"WebcamFeed: Error accessing webcam:\", err);\n        alert(\"Could not access the webcam. Please ensure you have a camera connected and grant permission.\");\n      }\n    };\n\n    startWebcam();\n\n    // Cleanup function to stop the webcam and interval\n    return () => {\n      console.log('WebcamFeed: Cleaning up webcam stream and interval.');\n      if (videoRef.current && videoRef.current.srcObject) {\n        const tracks = videoRef.current.srcObject.getTracks();\n        tracks.forEach(track => track.stop());\n      }\n      // Clear the interval using the ref\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n      }\n    };\n  }, []); // Empty dependency array means this effect runs only once on mount\n\n  useEffect(() => {\n    console.log('WebcamFeed: WebSocket or selectedCase changed. Checking conditions...');\n    console.log('WebcamFeed: websocket:', websocket, 'selectedCase:', selectedCase);\n\n    // Effect to send frames when WebSocket is connected and a case is selected\n    if (websocket && websocket.readyState === WebSocket.OPEN && selectedCase !== null) {\n      console.log(`WebcamFeed: Conditions met. Starting frame sending for case ${selectedCase}`);\n\n      // Clear any existing interval before starting a new one\n      if (frameIntervalRef.current) {\n        console.log('WebcamFeed: Clearing existing frame interval.');\n        clearInterval(frameIntervalRef.current);\n      }\n\n      // Store the new interval ID in the ref\n      frameIntervalRef.current = setInterval(() => {\n        if (videoRef.current && canvasRef.current) {\n          const context = canvasRef.current.getContext('2d');\n          // Set canvas dimensions to match video feed\n          canvasRef.current.width = videoRef.current.videoWidth;\n          canvasRef.current.height = videoRef.current.videoHeight;\n\n          // Draw the current video frame onto the canvas\n          context.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n\n          // Get image data from the canvas as a Base64 data URL\n          const dataUrl = canvasRef.current.toDataURL('image/jpeg', 0.7); // Specify image format and quality\n\n          if (websocket && websocket.readyState === WebSocket.OPEN) {\n             // Send frame data as Base64 string\n             // console.log('WebcamFeed: Sending frame data...'); // Uncomment for noisy logging\n             websocket.send(JSON.stringify({\n               case: selectedCase,\n               frame: dataUrl // Send the Base64 data URL string\n             }));\n          } else {\n              console.log('WebcamFeed: Cannot send frame. WebSocket not ready.');\n          }\n\n        } else {\n            console.log('WebcamFeed: Cannot capture frame. videoRef or canvasRef not ready.');\n        }\n      }, 100); // Send frame every 100ms (adjust as needed)\n\n    } else {\n      // Stop sending frames if WebSocket is not open or no case is selected\n      console.log(\"WebcamFeed: Conditions not met. Stopping frame sending.\");\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n        frameIntervalRef.current = null; // Reset interval ID\n      }\n    }\n\n    // Cleanup function to clear the interval when selectedCase or websocket changes\n    return () => {\n      console.log('WebcamFeed: Cleanup effect running. Clearing frame interval.');\n      if (frameIntervalRef.current) {\n        clearInterval(frameIntervalRef.current);\n        frameIntervalRef.current = null; // Reset interval ID\n      }\n    };\n\n  }, [websocket, selectedCase]); // Effect runs when websocket or selectedCase changes\n\n  return (\n    <div>\n      {/* The video element displays the raw webcam feed */}\n      <video ref={videoRef} autoPlay playsInline style={{ width: '100%', height: 'auto' }}></video>\n      {/* The canvas element is used to capture frames for sending (can be hidden if video is shown) */}\n      <canvas ref={canvasRef} style={{ display: 'none' }}></canvas> {/* Hide the canvas */}\n    </div>\n  );\n}\n\nexport default WebcamFeed;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}